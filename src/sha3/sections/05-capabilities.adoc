
[[hash_caps_reg]]
=== SHA3 and SHAKE Algorithm Capabilities Registration

Each SHA3 and SHAKE algorithm capability advertised *SHALL* be a self-contained JSON object. The following JSON values are used for hash algorithm capabilities:

[[caps_table]]

[cols="<,<,<"]
.SHA3 1.0 and SHAKE 1.0 Algorithm Capabilities JSON Values
|===
| JSON Value| Description| JSON type

| algorithm| The hash algorithm and mode to be validated.| string
| revision| The algorithm testing revision to use.| string
| inBit| Implementation does accept bit-oriented messages| boolean
| inEmpty| Implementation does accept null (zero-length) messages| boolean
| outputLen| Output length for SHAKE| domain
| outBit| SHAKE can output bit-oriented messages| boolean
| performLargeDataTest | Determines if the server should include the large data test group defined in <<LD_test>>. This property is *OPTIONAL*, and shall include the lengths in GiB being tested. Valid options are {1, 2, 4, 8}. | integer array
|===

NOTE: The lengths provided in the 'performLargeDataTest' property are in gibibytes. 1GiB is equivalent to 2^30 bytes. 

The following grid outlines which properties are *REQUIRED*, as well as all the possible values a server *MAY* support for SHA3 and SHAKE algorithms:

[[property_grid]]

[cols="<,<,<,<,<"]
.SHA3 and SHAKE Capabilities Applicability Grid
|===
| algorithm| inBit| inEmpty| outputLen| outBit| performLargeDataTest

| SHA3-224| true, false| true, false| | | true, false
| SHA3-256| true, false| true, false| | | true, false
| SHA3-384| true, false| true, false| | | true, false
| SHA3-512| true, false| true, false| | | true, false
| SHAKE-128| true, false| true, false| {"Min": 16, "Max": 65536, "Inc": any}| true, false |
| SHAKE-256| true, false| true, false| {"Min": 16, "Max": 65536, "Inc": any}| true, false |
|===

The following is a example JSON object advertising support for SHA3-256 for testing revision 1.0.

[source, json]
----
{
    "algorithm": "SHA3-256",
    "revision": "1.0",
    "inBit": true,
    "inEmpty": true,
    "performLargeDataTest": [1, 2, 4, 8]
}
----

The following is an example JSON object advertising support for SHAKE-128.

[source, json]
----
{
    "algorithm": "SHAKE-128",
    "revision": "1.0",
    "inBit": true,
    "inEmpty": true,
    "outBit": true,
    "outputLen": [
        {
        "min": 16,
        "max": 1024
        }
    ]
}
----

[cols="<,<,<"]
.SHA3 2.0 Algorithm Capabilities JSON Values

|===
| JSON Value| Description| JSON type

| algorithm| The hash algorithm and mode to be validated.| string
| revision| The algorithm testing revision to use.| string
| messageLength | Domain representing the message lengths supported. The current MCT implementation requires that the digest size and 3x the digest size of the registered hash algorithm must be a valid value within the registered domain.
| performLargeDataTest | Determines if the server should include the large data test group defined in <<LD_test>>. This property is *OPTIONAL*, and shall include the lengths in GiB being tested. Valid options are {1, 2, 4, 8}. | integer array
|===

NOTE: The lengths provided in the 'performLargeDataTest' property are in gibibytes. 1GiB is equivalent to 2^30 bytes. 

The following is a example JSON object advertising support for SHA3-256 for testing revision 2.0.

[source, json]
----
{
    "algorithm": "SHA3-256",
    "revision": "1.0",
    "inBit": true,
    "inEmpty": true,
    "messageLength": [{"min": 0, "max": 65536, "increment": 1}],
    "performLargeDataTest": [1, 2, 4, 8]
}
----

NOTE: Since the increment is 1 in the above, and the minimum value within the message length is zero, this is effectively an "inBit" and "inEmpty" registration from the 1.0 revision testing.  If the implementation supports only byte length messages, you could use an increment of 8.